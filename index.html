<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-pathVariable注解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/09/pathVariable%E6%B3%A8%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-04-09T05:32:06.000Z" itemprop="datePublished">2022-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/09/pathVariable%E6%B3%A8%E8%A7%A3/">pathVariable注解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="PathVariable主要作用：映射URL绑定的占位符"><a href="#PathVariable主要作用：映射URL绑定的占位符" class="headerlink" title="@PathVariable主要作用：映射URL绑定的占位符"></a><strong>@PathVariable主要作用：映射URL绑定的占位符</strong></h4><p>带占位符的URL是 Spring3.0 新增的功能，URL中的 {xxx} 占位符可以通过 @PathVariable(“xxx”) 绑定到操作方法的入参中</p>
<h5 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testPathVariable</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;路径上的占位符的值=&quot;</span>+id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如你的请求为localhost:8080&#x2F;user&#x2F;shortLink，可以输出：</p>
<h6 id="路径上的占位符的值-x3D-shortLink"><a href="#路径上的占位符的值-x3D-shortLink" class="headerlink" title="路径上的占位符的值&#x3D;shortLink"></a>路径上的占位符的值&#x3D;shortLink</h6>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/09/pathVariable%E6%B3%A8%E8%A7%A3/" data-id="cl1rfkjje000258us2mrkb3uh" data-title="pathVariable注解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="texthexo-aop和di的关系" class="h-entry article article-type-texthexo" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/02/aop%E5%92%8Cdi%E7%9A%84%E5%85%B3%E7%B3%BB/" class="article-date">
  <time class="dt-published" datetime="2022-04-02T15:45:00.000Z" itemprop="datePublished">2022-04-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/02/aop%E5%92%8Cdi%E7%9A%84%E5%85%B3%E7%B3%BB/">spring的aop和di的关系</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="spring的aop和di-的关系"><a href="#spring的aop和di-的关系" class="headerlink" title="spring的aop和di 的关系"></a>spring的aop和di 的关系</h4><h5 id="从getter和setter开始"><a href="#从getter和setter开始" class="headerlink" title="从getter和setter开始"></a>从getter和setter开始</h5><p>从开始学习mvc设计模式，或者是jsp异或是框架，必然会有JavaBean或者其他类似的概念出现。getter和setter就是JavaBean中的重要部分，通过这种方式，不需要考虑依赖对象的创建过程，省去了内部出现new的情况，大大降低了耦合性。但是这种方式只是把底层的耦合性降低，依赖关系还是需要高层的Java程序将依赖对象注入。<br>所以不满足的程序员提出了问题，耦合性的降低是否还可以更进一步？<br>所以就有了ioc和di的出现，很多框架甚至是所有的框架，都实现了ioc的功能 ，spring也不例外而ioc和di的概念也紧随其后，做为spring的功能的解释。<br>之前一直错误的以为ioc和di是因为spring才出现的，实则不然，spring是一个良好的嵌入这两个功能的框架，但这两个功能或者说是思想，是因为需求才出现的，而框架是这些优良思想的具体实现和整合。</p>
<h5 id="ioc的出现"><a href="#ioc的出现" class="headerlink" title="ioc的出现"></a>ioc的出现</h5><p>ioc，inverse of control，控制反转。直接理解一下就是，将耦合关系的控制权力反转，或者说是将依赖注入的权力反转。本来依赖注入是谁控制的，Java类自己new对象。后来是高层对象创建后，用setter方法注入，而且还增加了高层对象对于依赖对象的维护。ioc的出现就极大的解决了这些问题，ioc容器接管了依赖注入的权力，全部由ioc容器来控制。这就是控制反转，由应用程序控制反转为ioc容器控制。其实，ioc的概念，已经不是仅仅程序的反转控制了，而是完全的外部资源控制。<br>不过，还有一些问题<br>ioc的反转控制没错，但它还内涵了依赖注入的意思。可是字面上并没有体现，所以Martin Fowler 在2004年初的一篇论文中首次提出了di这一名词。</p>
<h5 id="di的出现"><a href="#di的出现" class="headerlink" title="di的出现"></a>di的出现</h5><p>di，dependency injection，依赖注入。di就是在指ioc容器内实现的将依赖对象注入的概念。<br>而依赖注入这一概念的实现，必然也内涵着权力控制的条件，否则spring没有基础的控制权力，如何注入。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>ioc和di一个意思其实并没有错。ioc作为率先提出的概念内涵着一部分概念，不直接，有些难受，就提出了di。很有意思的是，他们都内涵着对方的意思。<br>当然如果你要是强制认为，ioc就是容器，di就是注入这一行为，那么di确实就是ioc的具体功能的实现。而ioc则是di发挥的平台和空间。<br>所以说，ioc和di即是相辅相成的搭档，又是殊途同归的双胞胎。最重要的是，他们都是良好的降低耦合的思想。</p>
<p>当然，随着技术的发展，两者的概念可能会越来越分离，各自形成一个独立的体系。</p>
<p>版权声明：本文为CSDN博主「AStar3」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/astar3/article/details/80849233">https://blog.csdn.net/astar3/article/details/80849233</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/02/aop%E5%92%8Cdi%E7%9A%84%E5%85%B3%E7%B3%BB/" data-id="cl1rfkjjc000158ushrqv1l04" data-title="spring的aop和di的关系" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-JDBC连接池&amp;JDBCTemplate" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/01/JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0&JDBCTemplate/" class="article-date">
  <time class="dt-published" datetime="2022-04-01T14:09:23.483Z" itemprop="datePublished">2022-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><pre><code>1. 概念：其实就是一个容器(集合)，存放数据库连接的容器。
        当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。

2. 好处：
    1. 节约资源
    2. 用户访问高效

3. 实现：
    1. 标准接口：DataSource   javax.sql包下的
        1. 方法：
            * 获取连接：getConnection()
            * 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接

    2. 一般我们不去实现它，有数据库厂商来实现
        1. C3P0：数据库连接池技术
        2. Druid：数据库连接池实现技术，由阿里巴巴提供的


4. C3P0：数据库连接池技术
    * 步骤：
        1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，
            * 不要忘记导入数据库驱动jar包
        2. 定义配置文件：
            * 名称： c3p0.properties 或者 c3p0-config.xml
            * 路径：直接将文件放在src目录下即可。

        3. 创建核心对象 数据库连接池对象 ComboPooledDataSource
        4. 获取连接： getConnection
    * 代码：
         //1.创建数据库连接池对象
        DataSource ds  = new ComboPooledDataSource();
        //2. 获取连接对象
        Connection conn = ds.getConnection();
5. Druid：数据库连接池实现技术，由阿里巴巴提供的
    1. 步骤：
        1. 导入jar包 druid-1.0.9.jar
        2. 定义配置文件：
            * 是properties形式的
            * 可以叫任意名称，可以放在任意目录下
        3. 加载配置文件。Properties
        4. 获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory
        5. 获取连接：getConnection
    * 代码：
         //3.加载配置文件
        Properties pro = new Properties();
        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);
        pro.load(is);
        //4.获取连接池对象
        DataSource ds = DruidDataSourceFactory.createDataSource(pro);
        //5.获取连接
        Connection conn = ds.getConnection();
    2. 定义工具类
        1. 定义一个类 JDBCUtils
        2. 提供静态代码块加载配置文件，初始化连接池对象
        3. 提供方法
            1. 获取连接方法：通过数据库连接池获取连接
            2. 释放资源
            3. 获取连接池的方法


    * 代码：
        public class JDBCUtils &#123;

            //1.定义成员变量 DataSource
            private static DataSource ds ;
        
            static&#123;
                try &#123;
                    //1.加载配置文件
                    Properties pro = new Properties();
                    pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));
                    //2.获取DataSource
                    ds = DruidDataSourceFactory.createDataSource(pro);
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        
            /**
             * 获取连接
             */
            public static Connection getConnection() throws SQLException &#123;
                return ds.getConnection();
            &#125;
        
            /**
             * 释放资源
             */
            public static void close(Statement stmt,Connection conn)&#123;
               /* if(stmt != null)&#123;
                    try &#123;
                        stmt.close();
                    &#125; catch (SQLException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
        
                if(conn != null)&#123;
                    try &#123;
                        conn.close();//归还连接
                    &#125; catch (SQLException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;*/
        
               close(null,stmt,conn);
            &#125;
</code></pre>
<p>​<br>​                public static void close(ResultSet rs , Statement stmt, Connection conn){</p>
<p>​<br>​                    if(rs !&#x3D; null){<br>​                        try {<br>​                            rs.close();<br>​                        } catch (SQLException e) {<br>​                            e.printStackTrace();<br>​                        }<br>​                    }</p>
<p>​<br>​                    if(stmt !&#x3D; null){<br>​                        try {<br>​                            stmt.close();<br>​                        } catch (SQLException e) {<br>​                            e.printStackTrace();<br>​                        }<br>​                    }<br>​<br>                    if(conn !&#x3D; null){<br>                        try {<br>                            conn.close();&#x2F;&#x2F;归还连接<br>                        } catch (SQLException e) {<br>                            e.printStackTrace();<br>                        }<br>                    }<br>                }</p>
<pre><code>            /**
             * 获取连接池方法
             */
        
            public static DataSource getDataSource()&#123;
                return  ds;
            &#125;
        
        &#125;
</code></pre>
<h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><pre><code>* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发
* 步骤：
    1. 导入jar包
    2. 创建JdbcTemplate对象。依赖于数据源DataSource
        * JdbcTemplate template = new JdbcTemplate(ds);

    3. 调用JdbcTemplate的方法来完成CRUD的操作
        * update():执行DML语句。增、删、改语句
        * queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合
            * 注意：这个方法查询的结果集长度只能是1
        * queryForList():查询结果将结果集封装为list集合
            * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中
        * query():查询结果，将结果封装为JavaBean对象
            * query的参数：RowMapper
                * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装
                * new BeanPropertyRowMapper&lt;类型&gt;(类型.class)
        * queryForObject：查询结果，将结果封装为对象
            * 一般用于聚合函数的查询

    4. 练习：
        * 需求：
            1. 修改1号数据的 salary 为 10000
            2. 添加一条记录
            3. 删除刚才添加的记录
            4. 查询id为1的记录，将其封装为Map集合
            5. 查询所有记录，将其封装为List
            6. 查询所有记录，将其封装为Emp对象的List集合
            7. 查询总记录数

        * 代码：
            
            import cn.itcast.domain.Emp;
            import cn.itcast.utils.JDBCUtils;
            import org.junit.Test;
            import org.springframework.jdbc.core.BeanPropertyRowMapper;
            import org.springframework.jdbc.core.JdbcTemplate;
            import org.springframework.jdbc.core.RowMapper;
            
            import java.sql.Date;
            import java.sql.ResultSet;
            import java.sql.SQLException;
            import java.util.List;
            import java.util.Map;
            
            public class JdbcTemplateDemo2 &#123;
            
                //Junit单元测试，可以让方法独立执行
</code></pre>
<p>​<br>​                    &#x2F;&#x2F;1. 获取JDBCTemplate对象<br>​                    private JdbcTemplate template &#x3D; new JdbcTemplate(JDBCUtils.getDataSource());<br>​                    &#x2F;**<br>​                     * 1. 修改1号数据的 salary 为 10000<br>​                     *&#x2F;<br>​                    @Test<br>​                    public void test1(){<br>​<br>                        &#x2F;&#x2F;2. 定义sql<br>                        String sql &#x3D; “update emp set salary &#x3D; 10000 where id &#x3D; 1001”;<br>                        &#x2F;&#x2F;3. 执行sql<br>                        int count &#x3D; template.update(sql);<br>                        System.out.println(count);<br>                    }</p>
<pre><code>                /**
                 * 2. 添加一条记录
                 */
                @Test
                public void test2()&#123;
                    String sql = &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;;
                    int count = template.update(sql, 1015, &quot;郭靖&quot;, 10);
                    System.out.println(count);
            
                &#125;
            
                /**
                 * 3.删除刚才添加的记录
                 */
                @Test
                public void test3()&#123;
                    String sql = &quot;delete from emp where id = ?&quot;;
                    int count = template.update(sql, 1015);
                    System.out.println(count);
                &#125;
            
                /**
                 * 4.查询id为1001的记录，将其封装为Map集合
                 * 注意：这个方法查询的结果集长度只能是1
                 */
                @Test
                public void test4()&#123;
                    String sql = &quot;select * from emp where id = ? or id = ?&quot;;
                    Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002);
                    System.out.println(map);
                    //&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125;
            
                &#125;
            
                /**
                 * 5. 查询所有记录，将其封装为List
                 */
                @Test
                public void test5()&#123;
                    String sql = &quot;select * from emp&quot;;
                    List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);
            
                    for (Map&lt;String, Object&gt; stringObjectMap : list) &#123;
                        System.out.println(stringObjectMap);
                    &#125;
                &#125;
            
                /**
                 * 6. 查询所有记录，将其封装为Emp对象的List集合
                 */
            
                @Test
                public void test6()&#123;
                    String sql = &quot;select * from emp&quot;;
                    List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() &#123;
            
                        @Override
                        public Emp mapRow(ResultSet rs, int i) throws SQLException &#123;
                            Emp emp = new Emp();
                            int id = rs.getInt(&quot;id&quot;);
                            String ename = rs.getString(&quot;ename&quot;);
                            int job_id = rs.getInt(&quot;job_id&quot;);
                            int mgr = rs.getInt(&quot;mgr&quot;);
                            Date joindate = rs.getDate(&quot;joindate&quot;);
                            double salary = rs.getDouble(&quot;salary&quot;);
                            double bonus = rs.getDouble(&quot;bonus&quot;);
                            int dept_id = rs.getInt(&quot;dept_id&quot;);
            
                            emp.setId(id);
                            emp.setEname(ename);
                            emp.setJob_id(job_id);
                            emp.setMgr(mgr);
                            emp.setJoindate(joindate);
                            emp.setSalary(salary);
                            emp.setBonus(bonus);
                            emp.setDept_id(dept_id);
            
                            return emp;
                        &#125;
                    &#125;);
</code></pre>
<p>​<br>​                        for (Emp emp : list) {<br>​                            System.out.println(emp);<br>​                        }<br>​                    }<br>​<br>                    &#x2F;**<br>                     * 6. 查询所有记录，将其封装为Emp对象的List集合<br>                     *&#x2F;</p>
<pre><code>                @Test
                public void test6_2()&#123;
                    String sql = &quot;select * from emp&quot;;
                    List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));
                    for (Emp emp : list) &#123;
                        System.out.println(emp);
                    &#125;
                &#125;
            
                /**
                 * 7. 查询总记录数
                 */
            
                @Test
                public void test7()&#123;
                    String sql = &quot;select count(id) from emp&quot;;
                    Long total = template.queryForObject(sql, Long.class);
                    System.out.println(total);
                &#125;
            
            &#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/01/JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0&JDBCTemplate/" data-id="cl1rfkjj7000058usb0z93vyg" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/04/09/pathVariable%E6%B3%A8%E8%A7%A3/">pathVariable注解</a>
          </li>
        
          <li>
            <a href="/2022/04/02/aop%E5%92%8Cdi%E7%9A%84%E5%85%B3%E7%B3%BB/">spring的aop和di的关系</a>
          </li>
        
          <li>
            <a href="/2022/04/01/JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0&JDBCTemplate/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>