<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL数据库事务的机制(总结)</title>
    <link href="/2022/04/12/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%9C%BA%E5%88%B6-%E6%80%BB%E7%BB%93/"/>
    <url>/2022/04/12/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%9C%BA%E5%88%B6-%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>​        这几天面试多次被问到了数据库事务机制、隔离级别、<a href="https://so.csdn.net/so/search?q=%E4%B9%90%E8%A7%82%E9%94%81&spm=1001.2101.3001.7020">乐观锁</a>悲观锁类的问题，之前对这些只能说有所了解，有些概念还停留在记忆层面，没有理解，所以回答的不好。后面翻书学习了下，理解了一些东西，在此做一个记录。</p><h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h4><p>​        事务我理解的是一个完整的业务行为，一个业务行为可能包含多个动作，这个完整的动作就构成一个事务。比较经典的例子是银行转账，A账户转到B账户，需要两个动作：A账户减，B账户加，必须保证这两个动作要么都做，要么都不做。</p><h4 id="事务具有ACID特征，具体包括："><a href="#事务具有ACID特征，具体包括：" class="headerlink" title="事务具有ACID特征，具体包括："></a>事务具有ACID特征，具体包括：</h4><ul><li>原子性(atomicity)：原子性是说事务的不可分割，要么全成功，要么全失败，不可部分成功，部分失败。半途失败的情况下，需要打扫战场，也就是数据回滚。</li><li>一致性(consistency)：一致性是说事务的最后结果，要保证数据上没有异常。一致性是强调结果，是建立在原子性上实现的，也就是说能保证原子性，那就会有一致性的结果。</li><li>隔离性(isolation)：隔离性是说事务没有提交前对其他事务是不可见的，事务间数据是隔离的(当然不同级别隔离程度不一样)。</li><li>持久性(durability): 事务提交后会持久化，可以长久保存。</li></ul><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a><strong>事务隔离级别</strong></h4><p>了解事务的隔离级别之前，需要明白数据读取的几个概念：</p><ul><li>脏读：就是读到了别人还没提交的数据。</li><li>可重复读：就是同一个事物内的两次查询，中间如果别人修改了查询内的记录且提交了，对第二次查询是不可见的，不会出现同条记录两次查询不一致问题。</li><li>幻读：就是一个事物内的两次查询，中间如果别人增加了记录并且提交了，第二次查询能查询到的，会出现和第一次记录不一致的现象。</li></ul><p>事务的控制分很多个级别，级别的高低决定隔离的程度，MySQL中分四个级别：</p><ul><li>读未提交：这种级别是最低的，A事务的修改没有提交对B事物是可见的，会出现数据的脏读，一般情况下不会用到此种类型。</li><li>读已提交：A事物的修改提交后才对B可见，这种情况会出现数据的幻读的问题，两次查询的结果不一样。</li><li>可重复读：是MySQL默认的级别，这种级别事物内的两次查询，中间其他修改了某条记录，对其他事务是不可见的，保证了重复查的情况下同条记录的一致性，但是对于新增的情况其他事务是可见的，所以还是会出现新增幻读的现象。</li><li>可串行化：事务之间是串行执行的，对查询到的每条记录都加锁，会出现阻塞的情况，并发情况下会造成严重的性能问题，所以一般也不会用到这种类型。</li></ul><h5 id="1、锁"><a href="#1、锁" class="headerlink" title="1、锁"></a>1、锁</h5><p>MySQL当中的锁分读锁和写锁，读锁因为是读取数据所以可以多个同时读取同一份数据，具有共享性质；写锁涉及到数据的变动，所以和其他写锁和读锁是相冲突的，具有排他性质。</p><p>从锁的粒度上分表级锁和行级锁，表锁一般发生在对表结构的修改或对全表更新的时候，会阻塞所有对这张表的读写操作；行级锁一般发生在指定记录更新的时候，只会锁定指定记录。锁的粒度越小并发度越高，能优先行级锁尽量不要表锁，和程序中锁的粒度是一样的原则。</p><h5 id="2、多版本并发控制"><a href="#2、多版本并发控制" class="headerlink" title="2、多版本并发控制"></a>2、多版本并发控制</h5><p>MySQL为了性能考虑除了行级锁以外还是另外一种方式，多版本并发控制，这中控制是由存储引擎实现。</p><p>书中说明了InnoDB一种简单的实现方式，这种方式是采用一条记录多个版本的方式，每条记录上增加了两个隐藏列，一个是创建版本号，一个是删除版本号，每开启一个事务都会分配一个事务版本号，事务版本号是递增的，事务内操作都会根据这个版本号比较。</p><p>具体如下：</p><ul><li>查询时：查询当前事务之前存在的记录和本事务创建的记录，且没有被删除的，即：创建版本号&lt;&#x3D;当前版本号 &amp;&amp; (删除版本号为空 || 删除版本号 &gt; 当前版本号)</li><li>插入时：记录的创建版本号为当前事务版本号。</li><li>删除时：更新记录的删除版本号为当前事务版本号。</li><li>更新时：插入一条新记录，创建版本号为当前事务版本号，同时把原记录删除版本号改为当前事务版本号，代表已经删除。实际上这里的更新相当于删除再加一条记录。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>线程池之ThreandPoolExecutor</title>
    <link href="/2022/04/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BThreandPoolExecutor/"/>
    <url>/2022/04/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BThreandPoolExecutor/</url>
    
    <content type="html"><![CDATA[<h5 id="ThreadPoolExecutor提供了四个构造方法："><a href="#ThreadPoolExecutor提供了四个构造方法：" class="headerlink" title="ThreadPoolExecutor提供了四个构造方法："></a>ThreadPoolExecutor提供了四个构造方法：</h5><p><img src="D:\study\hexoBlog\public\img\thread1.png"></p><p>​                                                            ThreadPoolExecutor构造方法.png</p><h5 id="我们以最后一个构造方法（参数最多的那个），对其参数进行解释："><a href="#我们以最后一个构造方法（参数最多的那个），对其参数进行解释：" class="headerlink" title="我们以最后一个构造方法（参数最多的那个），对其参数进行解释："></a>我们以最后一个构造方法（参数最多的那个），对其参数进行解释：</h5><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, // <span class="hljs-number">1</span></span><br><span class="hljs-params">                             <span class="hljs-type">int</span> maximumPoolSize,  // <span class="hljs-number">2</span></span><br><span class="hljs-params">                             <span class="hljs-type">long</span> keepAliveTime,  // <span class="hljs-number">3</span></span><br><span class="hljs-params">                             TimeUnit unit,  // <span class="hljs-number">4</span></span><br><span class="hljs-params">                             BlockingQueue&lt;Runnable&gt; workQueue, // <span class="hljs-number">5</span></span><br><span class="hljs-params">                             ThreadFactory threadFactory,  // <span class="hljs-number">6</span></span><br><span class="hljs-params">                             RejectedExecutionHandler handler )</span> &#123; <span class="hljs-comment">//7</span><br>       <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>           maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>           maximumPoolSize &lt; corePoolSize ||<br>           keepAliveTime &lt; <span class="hljs-number">0</span>)<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>       <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>       <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>       <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>       <span class="hljs-built_in">this</span>.workQueue = workQueue;<br>       <span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>       <span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br>       <span class="hljs-built_in">this</span>.handler = handler;<br>   &#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>序号</strong></th><th><strong>名称</strong></th><th>类型</th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>1</td><td>corePoolSize</td><td>int</td><td>核心线程池大小</td></tr><tr><td>2</td><td>maximumPoolSize</td><td>int</td><td>最大线程池大小</td></tr><tr><td>3</td><td>keepAliveTime</td><td>long</td><td>线程最大空闲时间</td></tr><tr><td>4</td><td>unit</td><td>TimeUnit</td><td>时间单位</td></tr><tr><td>5</td><td>workQueue</td><td>BlockingQueue<Runnable></td><td>线程等待队列</td></tr><tr><td>6</td><td>threadFactory</td><td>ThreadFactory</td><td>线程创建工厂</td></tr><tr><td>7</td><td>handler</td><td>RejectedExecutionHandler</td><td>拒绝策略</td></tr></tbody></table><ul><li>知道了各个参数的作用后，我们开始构造符合我们期待的线程池。首先看JDK给我们预定义的几种线程池：</li></ul><h4 id="一、预定义线程池"><a href="#一、预定义线程池" class="headerlink" title="一、预定义线程池"></a>一、预定义线程池</h4><p>1.<strong>FixedThreadPool</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>corePoolSize与maximumPoolSize相等，即其线程全为核心线程，是一个固定大小的线程池，是其优势；</p></li><li><p>keepAliveTime &#x3D; 0 该参数默认对核心线程无效，而FixedThreadPool全部为核心线程；</p></li><li><p>workQueue 为LinkedBlockingQueue（无界阻塞队列），队列最大值为Integer.MAX_VALUE。如果任务提交速度持续大余任务处理速度，会造成队列大量阻塞。因为队列很大，很有可能在拒绝策略前，内存溢出。是其劣势；</p></li><li><p>FixedThreadPool的任务执行是无序的；</p></li></ul><p>适用场景：可用于Web服务瞬时削峰，但需注意长时间持续高峰情况造成的队列阻塞。</p><p>2.<strong>CachedThreadPool</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><p>适用场景：快速处理大量耗时较短的任务，如Netty的NIO接受请求时，可使用CachedThreadPool。</p><p>3.<strong>SingleThreadExecutor</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>           (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                   <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                   <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br>   &#125;<br></code></pre></td></tr></table></figure><p>咋一瞅，不就是newFixedThreadPool(1)吗？定眼一看，这里多了一层FinalizableDelegatedExecutorService包装，这一层有什么用呢，写个dome来解释一下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        ExecutorService fixedExecutorService = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">FixedThreadPool(1)</span>;<br>        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) fixedExecutorService;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(threadPoolExecutor.get<span class="hljs-constructor">MaximumPoolSize()</span>);<br>        threadPoolExecutor.set<span class="hljs-constructor">CorePoolSize(8)</span>;<br>        <br>        ExecutorService singleExecutorService = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">SingleThreadExecutor()</span>;<br><span class="hljs-comment">//      运行时异常 java.lang.ClassCastException</span><br><span class="hljs-comment">//      ThreadPoolExecutor threadPoolExecutor2 = (ThreadPoolExecutor) singleExecutorService;</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>对比可以看出，FixedThreadPool可以向下转型为ThreadPoolExecutor，并对其线程池进行配置，而SingleThreadExecutor被包装后，无法成功向下转型。<strong>因此，SingleThreadExecutor被定以后，无法修改，做到了真正的Single。</strong></p><p>4.<strong>ScheduledThreadPool</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title function_">newScheduledThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);<br>&#125;<br></code></pre></td></tr></table></figure><p>newScheduledThreadPool调用的是ScheduledThreadPoolExecutor的构造方法，而ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，构造是还是调用了其父类的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二、自定义线程池"><a href="#二、自定义线程池" class="headerlink" title="二、自定义线程池"></a>二、自定义线程池</h4><p>以下是自定义线程池，使用了有界队列，自定义ThreadFactory和拒绝策略的demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, IOException &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">corePoolSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maximumPoolSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">keepAliveTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">TimeUnit</span> <span class="hljs-variable">unit</span> <span class="hljs-operator">=</span> TimeUnit.SECONDS;<br>        BlockingQueue&lt;Runnable&gt; workQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">2</span>);<br>        <span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">threadFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NameTreadFactory</span>();<br>        <span class="hljs-type">RejectedExecutionHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyIgnorePolicy</span>();<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit,<br>                workQueue, threadFactory, handler);<br>        executor.prestartAllCoreThreads(); <span class="hljs-comment">// 预启动所有核心线程</span><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-type">MyTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTask</span>(String.valueOf(i));<br>            executor.execute(task);<br>        &#125;<br><br>        System.in.read(); <span class="hljs-comment">//阻塞主线程</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NameTreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ThreadFactory</span> &#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">mThreadNum</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, <span class="hljs-string">&quot;my-thread-&quot;</span> + mThreadNum.getAndIncrement());<br>            System.out.println(t.getName() + <span class="hljs-string">&quot; has been created&quot;</span>);<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyIgnorePolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>            doLog(r, e);<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doLog</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>            <span class="hljs-comment">// 可做日志记录等</span><br>            System.err.println( r.toString() + <span class="hljs-string">&quot; rejected&quot;</span>);<br><span class="hljs-comment">//          System.out.println(&quot;completedTaskCount: &quot; + e.getCompletedTaskCount());</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> String name;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyTask</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-built_in">this</span>.toString() + <span class="hljs-string">&quot; is running!&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">3000</span>); <span class="hljs-comment">//让任务执行慢点</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> name;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyTask [name=&quot;</span> + name + <span class="hljs-string">&quot;]&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="D:\study\hexoBlog\public\img\thread2.png"></p><p>其中线程线程1-4先占满了核心线程和最大线程数量，然后4、5线程进入等待队列，7-10线程被直接忽略拒绝执行，等1-4线程中有线程执行完后通知4、5线程继续执行。</p><h4 id="总结，通过自定义线程池，我们可以更好的让线程池为我们所用，更加适应我的实际场景。"><a href="#总结，通过自定义线程池，我们可以更好的让线程池为我们所用，更加适应我的实际场景。" class="headerlink" title="总结，通过自定义线程池，我们可以更好的让线程池为我们所用，更加适应我的实际场景。"></a>总结，通过自定义线程池，我们可以更好的让线程池为我们所用，更加适应我的实际场景。</h4><p>作者：徐志毅</p><p>链接：<a href="https://www.jianshu.com/p/f030aa5d7a28">https://www.jianshu.com/p/f030aa5d7a28</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pathVariable注解</title>
    <link href="/2022/04/09/pathVariable%E6%B3%A8%E8%A7%A3/"/>
    <url>/2022/04/09/pathVariable%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h4 id="PathVariable主要作用：映射URL绑定的占位符"><a href="#PathVariable主要作用：映射URL绑定的占位符" class="headerlink" title="@PathVariable主要作用：映射URL绑定的占位符"></a><strong>@PathVariable主要作用：映射URL绑定的占位符</strong></h4><p>带占位符的URL是 Spring3.0 新增的功能，URL中的 {xxx} 占位符可以通过 @PathVariable(“xxx”) 绑定到操作方法的入参中</p><h5 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h5><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/user/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testPathVariable</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> String id)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;路径上的占位符的值=&quot;</span>+id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>假如你的请求为localhost:8080&#x2F;user&#x2F;shortLink，可以输出：</p><h6 id="路径上的占位符的值-x3D-shortLink"><a href="#路径上的占位符的值-x3D-shortLink" class="headerlink" title="路径上的占位符的值&#x3D;shortLink"></a>路径上的占位符的值&#x3D;shortLink</h6>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>spring的aop和di的关系</title>
    <link href="/2022/04/02/spring%E7%9A%84aop%E5%92%8Cdi%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <url>/2022/04/02/spring%E7%9A%84aop%E5%92%8Cdi%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<h4 id="spring的aop和di-的关系"><a href="#spring的aop和di-的关系" class="headerlink" title="spring的aop和di 的关系"></a>spring的aop和di 的关系</h4><h5 id="从getter和setter开始"><a href="#从getter和setter开始" class="headerlink" title="从getter和setter开始"></a>从getter和setter开始</h5><p>从开始学习mvc设计模式，或者是jsp异或是框架，必然会有JavaBean或者其他类似的概念出现。getter和setter就是JavaBean中的重要部分，通过这种方式，不需要考虑依赖对象的创建过程，省去了内部出现new的情况，大大降低了耦合性。但是这种方式只是把底层的耦合性降低，依赖关系还是需要高层的Java程序将依赖对象注入。<br>所以不满足的程序员提出了问题，耦合性的降低是否还可以更进一步？<br>所以就有了ioc和di的出现，很多框架甚至是所有的框架，都实现了ioc的功能 ，spring也不例外而ioc和di的概念也紧随其后，做为spring的功能的解释。<br>之前一直错误的以为ioc和di是因为spring才出现的，实则不然，spring是一个良好的嵌入这两个功能的框架，但这两个功能或者说是思想，是因为需求才出现的，而框架是这些优良思想的具体实现和整合。</p><h5 id="ioc的出现"><a href="#ioc的出现" class="headerlink" title="ioc的出现"></a>ioc的出现</h5><p>ioc，inverse of control，控制反转。直接理解一下就是，将耦合关系的控制权力反转，或者说是将依赖注入的权力反转。本来依赖注入是谁控制的，Java类自己new对象。后来是高层对象创建后，用setter方法注入，而且还增加了高层对象对于依赖对象的维护。ioc的出现就极大的解决了这些问题，ioc容器接管了依赖注入的权力，全部由ioc容器来控制。这就是控制反转，由应用程序控制反转为ioc容器控制。其实，ioc的概念，已经不是仅仅程序的反转控制了，而是完全的外部资源控制。<br>不过，还有一些问题<br>ioc的反转控制没错，但它还内涵了依赖注入的意思。可是字面上并没有体现，所以Martin Fowler 在2004年初的一篇论文中首次提出了di这一名词。</p><h5 id="di的出现"><a href="#di的出现" class="headerlink" title="di的出现"></a>di的出现</h5><p>di，dependency injection，依赖注入。di就是在指ioc容器内实现的将依赖对象注入的概念。<br>而依赖注入这一概念的实现，必然也内涵着权力控制的条件，否则spring没有基础的控制权力，如何注入。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>ioc和di一个意思其实并没有错。ioc作为率先提出的概念内涵着一部分概念，不直接，有些难受，就提出了di。很有意思的是，他们都内涵着对方的意思。<br>当然如果你要是强制认为，ioc就是容器，di就是注入这一行为，那么di确实就是ioc的具体功能的实现。而ioc则是di发挥的平台和空间。<br>所以说，ioc和di即是相辅相成的搭档，又是殊途同归的双胞胎。最重要的是，他们都是良好的降低耦合的思想。</p><p>当然，随着技术的发展，两者的概念可能会越来越分离，各自形成一个独立的体系。</p><p>版权声明：本文为CSDN博主「AStar3」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/astar3/article/details/80849233">https://blog.csdn.net/astar3/article/details/80849233</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/04/01/JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0&amp;JDBCTemplate/"/>
    <url>/2022/04/01/JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0&amp;JDBCTemplate/</url>
    
    <content type="html"><![CDATA[<h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><div class="code-wrapper"><pre><code class="hljs">1. 概念：其实就是一个容器(集合)，存放数据库连接的容器。        当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。2. 好处：    1. 节约资源    2. 用户访问高效3. 实现：    1. 标准接口：DataSource   javax.sql包下的        1. 方法：            * 获取连接：getConnection()            * 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接    2. 一般我们不去实现它，有数据库厂商来实现        1. C3P0：数据库连接池技术        2. Druid：数据库连接池实现技术，由阿里巴巴提供的4. C3P0：数据库连接池技术    * 步骤：        1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，            * 不要忘记导入数据库驱动jar包        2. 定义配置文件：            * 名称： c3p0.properties 或者 c3p0-config.xml            * 路径：直接将文件放在src目录下即可。        3. 创建核心对象 数据库连接池对象 ComboPooledDataSource        4. 获取连接： getConnection    * 代码：         //1.创建数据库连接池对象        DataSource ds  = new ComboPooledDataSource();        //2. 获取连接对象        Connection conn = ds.getConnection();5. Druid：数据库连接池实现技术，由阿里巴巴提供的    1. 步骤：        1. 导入jar包 druid-1.0.9.jar        2. 定义配置文件：            * 是properties形式的            * 可以叫任意名称，可以放在任意目录下        3. 加载配置文件。Properties        4. 获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory        5. 获取连接：getConnection    * 代码：         //3.加载配置文件        Properties pro = new Properties();        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);        pro.load(is);        //4.获取连接池对象        DataSource ds = DruidDataSourceFactory.createDataSource(pro);        //5.获取连接        Connection conn = ds.getConnection();    2. 定义工具类        1. 定义一个类 JDBCUtils        2. 提供静态代码块加载配置文件，初始化连接池对象        3. 提供方法            1. 获取连接方法：通过数据库连接池获取连接            2. 释放资源            3. 获取连接池的方法    * 代码：        public class JDBCUtils &#123;            //1.定义成员变量 DataSource            private static DataSource ds ;                    static&#123;                try &#123;                    //1.加载配置文件                    Properties pro = new Properties();                    pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));                    //2.获取DataSource                    ds = DruidDataSourceFactory.createDataSource(pro);                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;                    /**             * 获取连接             */            public static Connection getConnection() throws SQLException &#123;                return ds.getConnection();            &#125;                    /**             * 释放资源             */            public static void close(Statement stmt,Connection conn)&#123;               /* if(stmt != null)&#123;                    try &#123;                        stmt.close();                    &#125; catch (SQLException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                        if(conn != null)&#123;                    try &#123;                        conn.close();//归还连接                    &#125; catch (SQLException e) &#123;                        e.printStackTrace();                    &#125;                &#125;*/                       close(null,stmt,conn);            &#125;</code></pre></div><p>​<br>​                public static void close(ResultSet rs , Statement stmt, Connection conn){</p><p>​<br>​                    if(rs !&#x3D; null){<br>​                        try {<br>​                            rs.close();<br>​                        } catch (SQLException e) {<br>​                            e.printStackTrace();<br>​                        }<br>​                    }</p><p>​<br>​                    if(stmt !&#x3D; null){<br>​                        try {<br>​                            stmt.close();<br>​                        } catch (SQLException e) {<br>​                            e.printStackTrace();<br>​                        }<br>​                    }<br>​<br>                    if(conn !&#x3D; null){<br>                        try {<br>                            conn.close();&#x2F;&#x2F;归还连接<br>                        } catch (SQLException e) {<br>                            e.printStackTrace();<br>                        }<br>                    }<br>                }</p><div class="code-wrapper"><pre><code class="hljs">            /**             * 获取连接池方法             */                    public static DataSource getDataSource()&#123;                return  ds;            &#125;                &#125;</code></pre></div><h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><div class="code-wrapper"><pre><code class="hljs">* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发* 步骤：    1. 导入jar包    2. 创建JdbcTemplate对象。依赖于数据源DataSource        * JdbcTemplate template = new JdbcTemplate(ds);    3. 调用JdbcTemplate的方法来完成CRUD的操作        * update():执行DML语句。增、删、改语句        * queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合            * 注意：这个方法查询的结果集长度只能是1        * queryForList():查询结果将结果集封装为list集合            * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中        * query():查询结果，将结果封装为JavaBean对象            * query的参数：RowMapper                * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装                * new BeanPropertyRowMapper&lt;类型&gt;(类型.class)        * queryForObject：查询结果，将结果封装为对象            * 一般用于聚合函数的查询    4. 练习：        * 需求：            1. 修改1号数据的 salary 为 10000            2. 添加一条记录            3. 删除刚才添加的记录            4. 查询id为1的记录，将其封装为Map集合            5. 查询所有记录，将其封装为List            6. 查询所有记录，将其封装为Emp对象的List集合            7. 查询总记录数        * 代码：                        import cn.itcast.domain.Emp;            import cn.itcast.utils.JDBCUtils;            import org.junit.Test;            import org.springframework.jdbc.core.BeanPropertyRowMapper;            import org.springframework.jdbc.core.JdbcTemplate;            import org.springframework.jdbc.core.RowMapper;                        import java.sql.Date;            import java.sql.ResultSet;            import java.sql.SQLException;            import java.util.List;            import java.util.Map;                        public class JdbcTemplateDemo2 &#123;                            //Junit单元测试，可以让方法独立执行</code></pre></div><p>​<br>​                    &#x2F;&#x2F;1. 获取JDBCTemplate对象<br>​                    private JdbcTemplate template &#x3D; new JdbcTemplate(JDBCUtils.getDataSource());<br>​                    &#x2F;**<br>​                     * 1. 修改1号数据的 salary 为 10000<br>​                     *&#x2F;<br>​                    @Test<br>​                    public void test1(){<br>​<br>                        &#x2F;&#x2F;2. 定义sql<br>                        String sql &#x3D; “update emp set salary &#x3D; 10000 where id &#x3D; 1001”;<br>                        &#x2F;&#x2F;3. 执行sql<br>                        int count &#x3D; template.update(sql);<br>                        System.out.println(count);<br>                    }</p><div class="code-wrapper"><pre><code class="hljs">                /**                 * 2. 添加一条记录                 */                @Test                public void test2()&#123;                    String sql = &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;;                    int count = template.update(sql, 1015, &quot;郭靖&quot;, 10);                    System.out.println(count);                            &#125;                            /**                 * 3.删除刚才添加的记录                 */                @Test                public void test3()&#123;                    String sql = &quot;delete from emp where id = ?&quot;;                    int count = template.update(sql, 1015);                    System.out.println(count);                &#125;                            /**                 * 4.查询id为1001的记录，将其封装为Map集合                 * 注意：这个方法查询的结果集长度只能是1                 */                @Test                public void test4()&#123;                    String sql = &quot;select * from emp where id = ? or id = ?&quot;;                    Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002);                    System.out.println(map);                    //&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125;                            &#125;                            /**                 * 5. 查询所有记录，将其封装为List                 */                @Test                public void test5()&#123;                    String sql = &quot;select * from emp&quot;;                    List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);                                for (Map&lt;String, Object&gt; stringObjectMap : list) &#123;                        System.out.println(stringObjectMap);                    &#125;                &#125;                            /**                 * 6. 查询所有记录，将其封装为Emp对象的List集合                 */                            @Test                public void test6()&#123;                    String sql = &quot;select * from emp&quot;;                    List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() &#123;                                    @Override                        public Emp mapRow(ResultSet rs, int i) throws SQLException &#123;                            Emp emp = new Emp();                            int id = rs.getInt(&quot;id&quot;);                            String ename = rs.getString(&quot;ename&quot;);                            int job_id = rs.getInt(&quot;job_id&quot;);                            int mgr = rs.getInt(&quot;mgr&quot;);                            Date joindate = rs.getDate(&quot;joindate&quot;);                            double salary = rs.getDouble(&quot;salary&quot;);                            double bonus = rs.getDouble(&quot;bonus&quot;);                            int dept_id = rs.getInt(&quot;dept_id&quot;);                                        emp.setId(id);                            emp.setEname(ename);                            emp.setJob_id(job_id);                            emp.setMgr(mgr);                            emp.setJoindate(joindate);                            emp.setSalary(salary);                            emp.setBonus(bonus);                            emp.setDept_id(dept_id);                                        return emp;                        &#125;                    &#125;);</code></pre></div><p>​<br>​                        for (Emp emp : list) {<br>​                            System.out.println(emp);<br>​                        }<br>​                    }<br>​<br>                    &#x2F;**<br>                     * 6. 查询所有记录，将其封装为Emp对象的List集合<br>                     *&#x2F;</p><div class="code-wrapper"><pre><code class="hljs">                @Test                public void test6_2()&#123;                    String sql = &quot;select * from emp&quot;;                    List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));                    for (Emp emp : list) &#123;                        System.out.println(emp);                    &#125;                &#125;                            /**                 * 7. 查询总记录数                 */                            @Test                public void test7()&#123;                    String sql = &quot;select count(id) from emp&quot;;                    Long total = template.queryForObject(sql, Long.class);                    System.out.println(total);                &#125;                        &#125;</code></pre></div>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
